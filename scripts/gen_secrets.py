#!/usr/bin/env python3
"""
scripts/gen_secrets.py

Reads config/secrets.yaml, validates every entry against a strict
schema, then appends any missing secrets to .env.local.

Existing keys are never overwritten â€” safe to re-run at any time.

Invoked by scripts/gen-secrets.sh, but can also be run directly:
    python3 scripts/gen_secrets.py --config config/secrets.yaml \\
                                   --env-file .env.local
"""
from __future__ import annotations

import argparse
import base64
import os
import re
import secrets as _secrets
import sys
from pathlib import Path
from typing import Any

try:
    import yaml
except ImportError:
    print("âŒ  PyYAML is not installed. Run: pip3 install pyyaml", file=sys.stderr)
    sys.exit(1)


# â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VALID_METHODS  = frozenset({"static", "random_base64", "random_hex", "fernet"})
ALLOWED_FIELDS = frozenset({"key", "method", "value", "length"})
KEY_RE         = re.compile(r"^[A-Z][A-Z0-9_]+$")
ENV_VAR_RE     = re.compile(r"^([A-Z][A-Z0-9_]+)=")

LENGTH_MIN     = 8
LENGTH_MAX     = 256
LENGTH_DEFAULT = 32

ENV_LOCAL_HEADER = (
    "# .env.local â€” LOCAL SECRETS & OVERRIDES\n"
    "# Auto-generated by `make up` via scripts/gen-secrets.sh.\n"
    "# âš ï¸  Never commit this file. It is listed in .gitignore.\n"
)


# â”€â”€ Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def validate(config: Any, config_path: str) -> list[dict]:
    """
    Validate the full YAML structure.

    Collects every error across all entries before raising so the user
    sees the complete list in one run rather than fixing one at a time.

    Returns the validated list of secret definitions on success.
    Calls sys.exit(1) with a formatted error report on failure.
    """
    errors: list[str] = []

    # â”€â”€ Top-level structure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if not isinstance(config, dict):
        _die(f"{config_path}: root must be a YAML mapping, got {type(config).__name__!r}")

    if "secrets" not in config:
        _die(f"{config_path}: missing required top-level key 'secrets'")

    secrets = config["secrets"]

    if not isinstance(secrets, list):
        _die(f"{config_path}: 'secrets' must be a list, got {type(secrets).__name__!r}")

    if not secrets:
        _die(f"{config_path}: 'secrets' list is empty â€” nothing to generate")

    # â”€â”€ Per-entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    seen: dict[str, int] = {}   # key â†’ first-seen index, for duplicate detection

    for idx, entry in enumerate(secrets):
        loc = f"{config_path}: secrets[{idx}]"

        if not isinstance(entry, dict):
            errors.append(
                f"{loc}: each entry must be a YAML mapping, got {type(entry).__name__!r}"
            )
            continue

        # Unknown fields
        unknown = sorted(set(entry) - ALLOWED_FIELDS)
        if unknown:
            errors.append(
                f"{loc}: unknown field(s): {', '.join(unknown)}  "
                f"(allowed: {', '.join(sorted(ALLOWED_FIELDS))})"
            )

        # â”€â”€ key â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        key: str = entry.get("key", "")
        label = key or f"<entry {idx}>"

        if not key:
            errors.append(f"{loc}: missing required field 'key'")
        elif not isinstance(key, str):
            errors.append(f"{loc}: 'key' must be a string, got {type(key).__name__!r}")
            label = f"<entry {idx}>"
        elif not KEY_RE.match(key):
            errors.append(
                f"{loc}: 'key' {key!r} is not a valid env var name "
                f"(must match ^[A-Z][A-Z0-9_]+$)"
            )

        # Duplicate check
        if key:
            if key in seen:
                errors.append(
                    f"{loc}: duplicate key {key!r} "
                    f"(first defined at secrets[{seen[key]}])"
                )
            else:
                seen[key] = idx

        # â”€â”€ method â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        method: str = entry.get("method", "")

        if not method:
            errors.append(f"{loc} ({label}): missing required field 'method'")
            continue   # remaining checks are method-dependent

        if not isinstance(method, str):
            errors.append(
                f"{loc} ({label}): 'method' must be a string, "
                f"got {type(method).__name__!r}"
            )
            continue

        if method not in VALID_METHODS:
            errors.append(
                f"{loc} ({label}): unknown method {method!r}  "
                f"(valid: {', '.join(sorted(VALID_METHODS))})"
            )
            continue

        has_value  = "value"  in entry
        has_length = "length" in entry
        value      = entry.get("value")
        length     = entry.get("length")

        # â”€â”€ static â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if method == "static":
            if not has_value:
                errors.append(
                    f"{loc} ({label}): method 'static' requires a 'value' field"
                )
            elif not isinstance(value, (str, int, float, bool)):
                errors.append(
                    f"{loc} ({label}): 'value' must be a scalar "
                    f"(string / number / bool), got {type(value).__name__!r}"
                )
            elif str(value).strip() == "":
                errors.append(
                    f"{loc} ({label}): 'value' must not be empty for method 'static'"
                )
            if has_length:
                errors.append(
                    f"{loc} ({label}): 'length' is not allowed for method 'static'"
                )

        # â”€â”€ random_base64 / random_hex â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elif method in ("random_base64", "random_hex"):
            if has_value:
                errors.append(
                    f"{loc} ({label}): 'value' is not allowed for method {method!r}"
                )
            if has_length:
                if not isinstance(length, int) or isinstance(length, bool):
                    errors.append(
                        f"{loc} ({label}): 'length' must be an integer, "
                        f"got {type(length).__name__!r}"
                    )
                elif not (LENGTH_MIN <= length <= LENGTH_MAX):
                    errors.append(
                        f"{loc} ({label}): 'length' must be between "
                        f"{LENGTH_MIN} and {LENGTH_MAX}, got {length}"
                    )

        # â”€â”€ fernet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elif method == "fernet":
            if has_value:
                errors.append(
                    f"{loc} ({label}): 'value' is not allowed for method 'fernet'"
                )
            if has_length:
                errors.append(
                    f"{loc} ({label}): 'length' is not allowed for method 'fernet' "
                    "(Fernet key length is fixed by the spec)"
                )

    if errors:
        print(
            f"\nâŒ  Schema validation failed â€” {len(errors)} error(s) "
            f"in {config_path}:\n",
            file=sys.stderr,
        )
        for i, err in enumerate(errors, 1):
            print(f"   {i}. {err}", file=sys.stderr)
        print(file=sys.stderr)
        sys.exit(1)

    return secrets  # type: ignore[return-value]


# â”€â”€ Generators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def gen_random_base64(length: int) -> str:
    """
    URL-safe base64 string with no +/= padding characters.
    Generates 2Ã— the bytes needed so stripping padding chars
    still yields at least `length` usable characters.
    """
    raw = _secrets.token_bytes(length * 2)
    return base64.urlsafe_b64encode(raw).rstrip(b"=").decode()[:length]


def gen_random_hex(length: int) -> str:
    """Lowercase hexadecimal string of exactly `length` characters."""
    return _secrets.token_hex(length)[:length]


def gen_fernet() -> str:
    """
    32-byte URL-safe base64 Fernet key.
    Prefers cryptography.fernet; falls back to stdlib when the
    cryptography package is not installed.
    """
    try:
        from cryptography.fernet import Fernet
        return Fernet.generate_key().decode()
    except ImportError:
        # Fernet key = urlsafe_b64encode(32 random bytes), padded to 44 chars
        return base64.urlsafe_b64encode(os.urandom(32)).decode()


def generate(entry: dict) -> str:
    """Dispatch to the correct generator and return the secret value."""
    method: str = entry["method"]
    length: int = entry.get("length", LENGTH_DEFAULT)

    if method == "static":
        return str(entry["value"])
    elif method == "random_base64":
        return gen_random_base64(length)
    elif method == "random_hex":
        return gen_random_hex(length)
    elif method == "fernet":
        return gen_fernet()
    else:
        # Unreachable â€” validation already rejected unknown methods
        raise ValueError(f"Unknown method: {method!r}")


# â”€â”€ .env.local helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def bootstrap(env_local: Path) -> None:
    """Create .env.local with a header comment if it does not exist."""
    if not env_local.exists():
        env_local.write_text(ENV_LOCAL_HEADER, encoding="utf-8")
        print(f"\nğŸ“„  Created {env_local}")


def read_existing_keys(env_local: Path) -> set[str]:
    """Return the set of env var names already defined in .env.local."""
    if not env_local.exists():
        return set()
    keys: set[str] = set()
    for line in env_local.read_text(encoding="utf-8").splitlines():
        m = ENV_VAR_RE.match(line)
        if m:
            keys.add(m.group(1))
    return keys


def append_secret(env_local: Path, key: str, value: str) -> None:
    """Append a single KEY=VALUE line to .env.local."""
    with env_local.open("a", encoding="utf-8") as fh:
        fh.write(f"{key}={value}\n")


# â”€â”€ CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate secrets from config/secrets.yaml into .env.local",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--config",
        default="config/secrets.yaml",
        metavar="PATH",
        help="Path to secrets.yaml (default: config/secrets.yaml)",
    )
    parser.add_argument(
        "--env-file",
        default=".env.local",
        metavar="PATH",
        dest="env_file",
        help="Path to .env.local (default: .env.local)",
    )
    return parser.parse_args()


# â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main() -> None:
    args = parse_args()

    config_path = Path(args.config)
    env_local   = Path(args.env_file)

    # â”€â”€ Load YAML â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if not config_path.exists():
        _die(
            f"Secrets config not found: {config_path}\n"
            f"   Expected at: {config_path.resolve()}"
        )

    with config_path.open(encoding="utf-8") as fh:
        try:
            config = yaml.safe_load(fh)
        except yaml.YAMLError as exc:
            _die(f"Failed to parse {config_path}:\n   {exc}")

    # â”€â”€ Validate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    secret_defs = validate(config, str(config_path))

    # â”€â”€ Bootstrap .env.local â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    bootstrap(env_local)

    # â”€â”€ Generate missing secrets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    existing = read_existing_keys(env_local)

    print(
        f"\nğŸ”  Checking secrets in {env_local}  "
        f"(config: {config_path})...\n"
    )

    written: list[str] = []
    skipped: list[str] = []

    for entry in secret_defs:
        key: str = entry["key"]

        if key in existing:
            skipped.append(key)
            continue

        value = generate(entry)
        append_secret(env_local, key, value)
        written.append(key)
        print(f"   âœ”  {key:<35}  [{entry['method']}]")

    # â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    print()
    if written:
        print(f"âœ…  {len(written)} secret(s) written to {env_local}")
        if skipped:
            print(
                f"â­ï¸   {len(skipped)} already present â€” skipped "
                f"({', '.join(skipped)})"
            )
        print(f"\n   Review:  cat {env_local}\n")
    else:
        print(
            f"âœ…  All {len(skipped)} secret(s) already present in "
            f"{env_local} â€” nothing changed.\n"
        )


def _die(msg: str) -> None:
    print(f"\nâŒ  {msg}\n", file=sys.stderr)
    sys.exit(1)


if __name__ == "__main__":
    main()